#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 2.3 (Thursday July 11th 2007) [Antoine-Auguste Parmentier]
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER F.MERIZEN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe
*/

/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.h) contains all basic Eiffel
  type definitions.
  This file is automatically included in the header for all modes of
  compilation: -boost, -no_check, -require_check, -ensure_check, ...
  This file is also included in the header of any cecil file (when the
  -cecil option is used).
  This file is also included in the header file of C++ wrappers (when
  using the external "C++" clause).
*/

#ifndef _BASE_H
#define _BASE_H

#if defined(_MSC_VER) && (_MSC_VER >= 1400)       /* VC8+ */
# ifndef _CRT_SECURE_NO_DEPRECATE
#  define _CRT_SECURE_NO_DEPRECATE
# endif
# ifndef _CRT_NONSTDC_NO_DEPRECATE
#  define _CRT_NONSTDC_NO_DEPRECATE
# endif
#endif   /* VC8+ */

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <signal.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <float.h>
#include <setjmp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  include <unistd.h>
#endif
#if !defined(WIN32) && \
       (defined(WINVER) || defined(_WIN32_WINNT) || defined(_WIN32) || \
	defined(__WIN32__) || defined(__TOS_WIN__) || defined(_MSC_VER))
#  define WIN32 1
#endif
#ifdef WIN32
#  include <windows.h>
#else
#  ifndef O_RDONLY
#    include <sys/file.h>
#  endif
#  ifndef O_RDONLY
#    define O_RDONLY 0000
#  endif
#endif

#if defined(_MSC_VER) && (_MSC_VER < 1500) /* MSVC older than v9 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "I64d"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c
#  define INT64_C(c) c ## i64
#elif defined(__WATCOMC__) && (__WATCOMC__ <= 1220) /* WATCOM 12.2 or lower */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__BORLANDC__) && (__BORLANDC__ < 0x600) /* Borland before 6.0 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "I64Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__FreeBSD__) && (__FreeBSD__ < 5) /* FreeBSD before 5.0 */ && !defined (_SYS_INTTYPES_H_)
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
#elif defined(__CYGWIN__) && defined(__BIT_TYPES_DEFINED__) /* Cygwin defines intxx_t in sys/types.h instead of inttypes.h */
#  include <cygwin/version.h>
#  if defined(CYGWIN_VERSION_DLL_MAJOR) && (CYGWIN_VERSION_DLL_MAJOR<1005)
typedef unsigned char uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
#  endif
#elif defined(SASC)
#    error("Too old SAS/C compiler, sorry.");
#elif defined(__SASC__)
#  if (__SASC__ < 750 ) /*  SAS/C before 7.50 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
#  endif
#else
#  include <inttypes.h>
#  if !defined(INT8_MAX) && defined(INT16_MAX)
/* int8_t is not mandatory */
typedef int_least8_t int8_t;
#  endif
#endif

#if !defined(PRId16)
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "lld"
#elif !defined(PRId8)
#  define PRId8 "d"
#endif
#if !defined(INT16_C)
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## LL
#elif !defined(INT8_C)
#  define INT8_C(c) c
#endif
#if !defined(INT16_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#  define INT8_MAX (INT8_C(127))
#  define INT16_MIN (-INT16_C(32767)-1)
#  define INT16_MAX (INT16_C(32767))
#  define INT32_MIN (-INT32_C(2147483647)-1)
#  define INT32_MAX (INT32_C(2147483647))
#  define INT64_MIN (-INT64_C(9223372036854775807)-1)
#  define INT64_MAX (INT64_C(9223372036854775807))
#elif !defined(INT8_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#endif


/*
  Endian stuff
*/
#if defined(BSD) && (BSD >= 199103)
#  include <machine/endian.h>
#elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
/* bi-endian processor, current mode should be find in machine/endian.h file */
#  include <machine/endian.h>
#elif defined(linux)
#  include <endian.h>
#endif



#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)
#  define BYTE_ORDER      __BYTE_ORDER
#endif

#if !defined(LITTLE_ENDIAN) && defined(__LITTLE_ENDIAN)
#  define LITTLE_ENDIAN      __LITTLE_ENDIAN
#endif

#if !defined(BIG_ENDIAN) && defined(__BIG_ENDIAN)
#  define BIG_ENDIAN      __BIG_ENDIAN
#endif

#if !defined(LITTLE_ENDIAN)
#  define LITTLE_ENDIAN   1234    /* LSB first (vax, pc) */
#endif
#if !defined(BIG_ENDIAN)
#  define BIG_ENDIAN      4321    /* MSB first (IBM, net) */
#endif
#if !defined(PDP_ENDIAN)
#  define PDP_ENDIAN      3412    /* LSB first in word, MSW first in long */
#endif

#if !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_RIGHT)
#  define BYTE_ORDER      LITTLE_ENDIAN
#elif !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_LEFT)
#  define BYTE_ORDER      BIG_ENDIAN
#elif !defined(BYTE_ORDER)

/* ARM */
#  if defined(__ARMEL__)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  elif defined(__ARMEB__)
#    define BYTE_ORDER      BIG_ENDIAN
#  elif defined(__arm__)
#    error "ARMs are bi-endian processors. Endianness is unknown for this system, please drop an e-mail to SmartEiffel@loria.fr"
#  endif

/* HP RISC */
#  if defined(__hppa__) || defined(__hppa) || defined(__hp9000) || \
      defined(__hp9000s300) || defined(hp9000s300) || \
      defined(__hp9000s700) || defined(hp9000s700) || \
      defined(__hp9000s800) || defined(hp9000s800) || defined(hp9000s820)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* IBM */
#  if defined(ibm032) || defined(ibm370) || defined(_IBMR2) || \
      defined(IBM370) || defined(__MVS__)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Intel x86 */
#  if defined(i386) || defined(__i386__) || defined(__i386) || \
      defined(_M_IX86) || defined(_X86_) || defined(__THW_INTEL) || \
      defined(sun386)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Intel Itanium */
#  if defined(__ia64__) || defined(_IA64) || defined(__IA64__) || \
      defined(_M_IA64)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Nationnal Semiconductor 32000 serie */
#  if  defined(ns32000)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Motorola 68000 */
#  if defined(mc68000) || defined(is68k) || defined(macII) || defined(m68k)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* MIPS */
#  if defined(MIPSEL) || defined(_MIPSEL)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  elif defined(MIPSEB) || defined(_MIPSEB)
#    define BYTE_ORDER      BIG_ENDIAN
#  elif defined(__mips__) || defined(__mips) || defined(__MIPS__)
#    error "MIPS are bi-endian processors. Endianness is unknown for this system, please drop an e-mail to SmartEiffel@loria.fr"
#  endif

/* Power PC */
/* this processor is bi-endian, how to know if little-endian is set? */
#  if defined(__powerpc) || defined(__powerpc__) || defined(__POWERPC__) || \
      defined(__ppc__) || defined(__ppc) || defined(_M_PPC) || \
      defined(__PPC) || defined(__PPC__)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Pyramid 9810 */
#  if defined(pyr)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* RS/6000 */
#  if defined(__THW_RS6000) || defined(_IBMR2) || defined(_POWER) || \
      defined(_ARCH_PWR) || defined(_ARCH_PWR2)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* SPARC */
#  if defined(__sparc__) || defined(sparc) || defined(__sparc)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* CCI Tahoe */
#  if defined(tahoe)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* VAX */
#  if defined(vax) || defined(VAX) || defined(__vax__) || defined(_vax_) || \
      defined(__vax) || defined(__VAX)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* ELATE is a virtual OS with a little endian Virtual Processor */
#  if defined(__ELATE__)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous little endian */
#  if defined(wrltitan)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous big endian */
#  if defined(apollo) || defined(__convex__) || defined(_CRAY) || defined(sel)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif
#endif


#if !defined(BYTE_ORDER)
#  error "Unknown byte order. Add your system in above macros once you know your system type. Please drop an e-mail to SmartEiffel@loria.fr"
#endif
#if (BYTE_ORDER != BIG_ENDIAN && BYTE_ORDER != LITTLE_ENDIAN)
#  error "Only little-endian and big-endian are valid at this time. Please drop an e-mail to SmartEiffel@loria.fr"
#endif


/*
  Byte swapping stuff
*/
extern void copy_swap_16(const uint16_t *src, uint16_t *dest, int count);


/* Because ANSI C EXIT_* are not always defined: */
#ifndef EXIT_FAILURE
#  define EXIT_FAILURE 1
#endif
#ifndef EXIT_SUCCESS
#  define EXIT_SUCCESS 0
#endif

/*
   On Linux glibc systems, we need to use sig.* versions of jmp_buf,
   setjmp and longjmp to preserve the signal handling context.
   Currently, the way I figured to detect this is if _SIGSET_H_types has
   been defined in /usr/include/setjmp.h.

   NOTE: with gcc, -ansi is used for SmartEiffel generated files EXCEPT in
   -no_split mode. ANSI only recognizes the non-sig versions.
*/
#if (defined(_SIGSET_H_types) && !defined(__STRICT_ANSI__))
#  define JMP_BUF    sigjmp_buf
#  define SETJMP(x)  sigsetjmp( (x), 1)
#  define LONGJMP    siglongjmp
#else
#  define JMP_BUF    jmp_buf
#  define SETJMP(x)  setjmp( (x) )
#  define LONGJMP    longjmp
#endif

/*
   Type to store reference objects Id:
 */
typedef int Tid;
typedef struct S0 T0;
struct S0{Tid id;};

/*
   The default channel used to print runtime error messages:
*/
#define SE_ERR stderr

/*
   Eiffel type INTEGER_8 is #1:
*/
typedef int8_t T1;
#define EIF_INTEGER_8 T1
#define M1 (INT8_C(0))
#define EIF_INTEGER_8_BITS (CHAR_BIT)
#define EIF_MINIMUM_INTEGER_8 (INT8_MIN)
#define EIF_MAXIMUM_INTEGER_8 (INT8_MAX)

/*
  Eiffel type INTEGER_16 is #10:
*/
typedef int16_t T10;
#define EIF_INTEGER_16 T10
#define M10 (INT16_C(0))
#define EIF_INTEGER_16_BITS (CHAR_BIT*sizeof(T10t))
#define EIF_MINIMUM_INTEGER_16 (INT16_MIN) /*-32768*/
#define EIF_MAXIMUM_INTEGER_16 (INT16_MAX) /*+32767*/

/*
  Eiffel type INTEGER or INTEGER_32 is #2:
*/
typedef int32_t T2;
#define EIF_INTEGER T2
#define EIF_INTEGER_32 T2
#define M2 (INT32_C(0))
#define EIF_INTEGER_BITS ((T2)(CHAR_BIT*sizeof(T2)))
#define EIF_INTEGER_32_BITS EIF_INTEGER_BITS
#define EIF_MINIMUM_INTEGER (INT32_MIN)
#define EIF_MAXIMUM_INTEGER (INT32_MAX)

/*
  Eiffel type INTEGER_64 is #11:
*/
typedef int64_t T11;
#define EIF_INTEGER_64 T11
#define M11 (INT64_C(0))
#define EIF_INTEGER_64_BITS (CHAR_BIT*sizeof(T11))
#define EIF_MINIMUM_INTEGER_64 (INT64_MIN)
#define EIF_MAXIMUM_INTEGER_64 (INT64_MAX)

/*
  Eiffel type CHARACTER is #3:
*/
typedef unsigned char T3;
#define EIF_CHARACTER T3
#define M3 (0)
#define EIF_CHARACTER_BITS (CHAR_BIT)
#define EIF_MINIMUM_CHARACTER_CODE (0)
#define EIF_MAXIMUM_CHARACTER_CODE (255)
#define T3code(x) ((T10)(x))
#define T3to_integer(x) ((signed char)(x))
#define T3to_integer_8(x) ((signed char)(x))
#define T3to_bit(x) (x)

/*
  Eiffel type REAL_32 is #4:
*/
typedef float T4;
typedef T4 real32_t;
#define EIF_REAL_32 T4
#define M4 (0.0)
#define EIF_MINIMUM_REAL_32 (-(FLT_MAX))
#define EIF_MAXIMUM_REAL_32 (FLT_MAX)

/*
  Eiffel type REAL or REAL_64 is #5:
*/
typedef double T5;
typedef T5 real64_t;
#define EIF_REAL_64 T5
#define M5 (0.0)
#define EIF_MINIMUM_REAL_64 (-(DBL_MAX))
#define EIF_MINIMUM_REAL (EIF_MINIMUM_REAL_64)
#define EIF_MAXIMUM_REAL_64 (DBL_MAX)
#define EIF_MAXIMUM_REAL (EIF_MAXIMUM_REAL_64)

/*
  Eiffel type REAL_EXTENDED is #12:
*/
typedef long double T12;
typedef T12 real_extended_t;
#define EIF_REAL_EXTENDED T12
#define M12 (0.0)
#define EIF_MINIMUM_REAL_EXTENDED (-(DBL_MAX))
#define EIF_MAXIMUM_REAL_EXTENDED (DBL_MAX)

/*
  Eiffel type BOOLEAN is #6:
*/
typedef char T6;
#define EIF_BOOLEAN T6
#define M6 (0)
#define EIF_BOOLEAN_BITS (CHAR_BIT)

/*
   Eiffel type POINTER is #8:
*/
typedef void* T8;
#define EIF_POINTER T8
/* Sometimes, NULL is defined as 0 */
#define M8 ((void*)NULL)
#define EIF_POINTER_BITS (CHAR_BIT*sizeof(void*))

/*
  To use type STRING on the C side:
*/
#define EIF_STRING T7*

/*
  Some Other EIF_* defined in ETL:
*/
#define eif_access(x) ((char*)(x))
#define EIF_REFERENCE T0*
#define EIF_OBJ T0*
#define EIF_OBJECT EIF_OBJ

/*
   Wrappers for `malloc' and `calloc':
*/
void* se_malloc(size_t size);
void* se_calloc(size_t nmemb, size_t size);
void* se_realloc(void* src, size_t size);

/*
   die method.
 */
void se_die(int code);

/*
    Runtime hooks. They allow different runtime modules to be quite independant. In time, they will also allow
    thread-safe operations.

    Currently known modules:
      - boost
      - no_check
      - sedb
      - gc
      - print stack
      - profile
      - plugins

    However, currently only profile uses this method. It will be extended to other modules later.

    The currently defined hooks are described in the enum below (the names should be self-explanatory).
 */
typedef enum {
  SE_HANDLE_EXCEPTION_SET, /* called when an exception handler is set, prior to SETJMP */
  SE_HANDLE_EXCEPTION_CLEAR, /* called when a feature with an exception handler normally returns */
  SE_HANDLE_EXCEPTION_THROWN, /* called when an exception is thrown, prior to the LONGJMP */
  SE_HANDLE_ENTER_GC, /* called when gc_start() begins */
  SE_HANDLE_EXIT_GC, /* called when gc_start() ends */
  SE_HANDLE_ENTER_PRINT_STACK, /* called when se_print_run_time_stack() begins */
  SE_HANDLE_EXIT_PRINT_STACK, /* called when se_print_run_time_stack() ends */
  SE_HANDLE_NO_MORE_MEMORY, /* called by se_alloc() and co */
  SE_HANDLE_SEDB_BREAK, /* called when sedb stops the program */
  SE_HANDLE_SEDB_CONTINUE, /* called when sedb continues the program */
  SE_HANDLE_RUNTIME_ERROR, /* called when a runtime error is raised and not caught by an exception. Cannot be raised in boost mode. */
  SE_HANDLE_DIE_WITH_CODE, /* called when the program is stopped by the die_with_code feature. The data points to the int code. */
  SE_HANDLE_NORMAL_EXIT /* called when the program correctly terminates. The data is null. */
} se_handler_action_t;

extern int handlers_count;
typedef void se_runtime_handler_t(se_handler_action_t action, void*data);
void register_handler(se_runtime_handler_t*handler);
void _handle(se_handler_action_t action, void*data);

#define handle(action,data) do{if(handlers_count>0)_handle(action,data);}while(0)

#endif /* #ifndef _BASE_H */
#define SE_GC_LIB 1
/* C Header Pass 1: */
typedef struct S7 T7;
typedef struct S49 T49;
typedef struct S169 T169;
typedef struct S176 T176;
typedef struct S125 T125;
typedef struct S123 T123;
typedef struct S47 T47;
typedef struct S48 T48;
typedef struct S167 T167;
typedef struct S180 T180;
typedef struct S179 T179;
typedef struct S177 T177;
typedef struct S173 T173;
typedef struct S172 T172;
typedef struct S58 T58;
typedef struct S40 T40;
typedef struct S25 T25;
/* C Header Pass 2: */
typedef T0**T168;
#define M168 NULL
typedef T0**T183;
#define M183 NULL
typedef T0**T182;
#define M182 NULL
typedef T0**T178;
#define M178 NULL
typedef T0**T175;
#define M175 NULL
typedef T0**T174;
#define M174 NULL
typedef T3*T9;
#define M9 NULL
/* C Header Pass 3: */
/* C Header Pass 4: */
void se_prinT168(FILE* file,T168*o);
void se_prinT183(FILE* file,T183*o);
void se_prinT182(FILE* file,T182*o);
void se_prinT178(FILE* file,T178*o);
void se_prinT175(FILE* file,T175*o);
void se_prinT174(FILE* file,T174*o);
struct S47{Tid id;T0* _filter;T2 _buffer_position;T9 _buffer;T2 _capacity;};
extern T47 M47;
void se_prinT47(FILE* file,T47**o);
struct S48{Tid id;T0* _filter;T6 _end_of_input;T3 _filtered_last_character;T9 _buffer;T6 _end_reached;T2 _buffer_position;T2 _buffer_size;T2 _capacity;T6 _unread_character_flag;};
extern T48 M48;
void se_prinT48(FILE* file,T48**o);
struct S167{Tid id;T168 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T167 M167;
void se_prinT167(FILE* file,T167**o);
struct S49{Tid id;T0* _id;T0* _nom;T0* _prenom;T0* _adresse;T0* _date_naiss;};
extern T49 M49;
void se_prinT49(FILE* file,T49**o);
struct S180{Tid id;T183 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T180 M180;
void se_prinT180(FILE* file,T180**o);
struct S179{Tid id;T182 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T179 M179;
void se_prinT179(FILE* file,T179**o);
struct S169{Tid id;T0* _id;T0* _nom;T0* _prenom;T0* _adresse;T0* _date_naiss;T0* _matricule;};
extern T169 M169;
void se_prinT169(FILE* file,T169**o);
struct S176{Tid id;T0* _id_media;T0* _id_adh;T0* _date_emp;T0* _date_retour_p;T0* _date_retour_r;};
extern T176 M176;
void se_prinT176(FILE* file,T176**o);
struct S177{Tid id;T178 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T177 M177;
void se_prinT177(FILE* file,T177**o);
struct S125{Tid id;T0* _id;T0* _titre;T0* _genre;T2 _nb_exemplaires;T0* _date;T0* _realisateur;T0* _acteurs;T0* _type;};
extern T125 M125;
void se_prinT125(FILE* file,T125**o);
struct S173{Tid id;T175 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T173 M173;
void se_prinT173(FILE* file,T173**o);
struct S123{Tid id;T0* _id;T0* _titre;T0* _genre;T2 _nb_exemplaires;T0* _date;T0* _auteur;T2 _nb_pages;};
extern T123 M123;
void se_prinT123(FILE* file,T123**o);
struct S172{Tid id;T174 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T172 M172;
void se_prinT172(FILE* file,T172**o);
struct S58{Tid id;T0* _filter;T0* _path;T6 _end_of_input;T3 _filtered_last_character;T8 _input_stream;T9 _buffer;T6 _end_reached;T2 _buffer_position;T2 _buffer_size;T2 _capacity;};
extern T58 M58;
void se_prinT58(FILE* file,T58**o);
struct S40{Tid id;T0* _filter;T0* _output_filter;T2 _last_integer;T6 _valid_last_integer;T0* _input_filter;};
extern T40 M40;
void se_prinT40(FILE* file,T40**o);
struct S25{Tid id;T0* _dvd1;T0* _livre1;T0* _personnel1;T6 _final_test;T2 _x;T2 _choix_menu;T0* _adh_db;T0* _les_dvds;T0* _les_livres;T0* _les_emprunts;T0* _les_adherents;T0* _les_personnels;};
extern T25 M25;
void se_prinT25(FILE* file,T25**o);
void se_prinT9(FILE* file,T9*o);
struct S7{Tid id;T9 _storage;T2 _count;T2 _capacity;};
extern T7 M7;
extern char*s25_0;
extern char*s123_10;
extern char*s53_117797837;
extern char*s25_49;
extern char*s25_80024;
extern char*s25_1288382371;
extern char*s25_80025;
extern char*s25_80026;
extern char*s25_828004632;
extern char*s25_1671411445;
extern char*s25_12655;
extern char*s25_246077261;
extern char*s25_1215456525;
extern char*s25_686439774;
extern char*s25_1642274547;
extern char*s25_1247140614;
extern char*s25_39059665;
extern char*s25_1415551;
extern char*s25_1589597640;
extern char*s25_942204907;
extern char*s25_1347500488;
extern char*s25_380723356;
extern char*s25_918935899;
extern char*s25_56485;
extern char*s25_68809;
extern char*s25_1092283463;
extern char*s25_1074095061;
extern char*s25_1384757574;
extern char*s25_7743;
extern char*s25_7744;
extern char*s25_7745;
extern char*s25_348603427;
extern char*s25_2063693030;
extern char*s25_1892535409;
extern char*s25_589815136;
extern char*s25_365943406;
extern char*s25_1836543016;
extern char*s25_651872765;
extern char*s25_1113745388;
extern char*s25_1466554481;
extern char*s25_502194649;
extern char*s25_1542919310;
extern char*s25_8626194;
extern char*s25_1695359570;
extern char*s25_2614;
extern char*s25_2106424;
extern char*s25_1805389044;
extern char*s25_848988688;
extern char*s25_1054321593;
extern char*s25_1233266491;
extern char*s25_958470591;
extern char*s25_4684338;
extern char*s25_1032639664;
extern char*s25_2089430744;
extern char*s25_2048003804;
extern char*s25_342066;
extern char*s25_1110960600;
extern char*s25_123362262;
extern char*s25_1464108150;
extern char*s25_427178747;
extern char*s25_1095731081;
extern char*s25_733910884;
extern char*s25_836325128;
extern char*s25_229892030;
extern char*s25_224128780;
extern char*s25_717654312;
extern char*s25_1653461503;
extern char*s25_1739415609;
extern char*s25_337289;
extern char*s25_1108421545;
extern char*s25_1482033459;
extern char*s25_377473794;
extern char*s25_1562986780;
extern char*s25_17716;
extern char*s25_1539631482;
extern char*s25_565682599;
extern char*s25_2066182213;
extern char*s25_1779225763;
extern char*s25_1255677259;
extern char*s25_117108738;
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/no_check.h) is automatically included
  when `ace.no_check' is true (ie. all modes except mode -boost).
*/

void se_prinT0(FILE* file,T0** o);
void se_prinT1(FILE* file,EIF_INTEGER_8* o);
void se_prinT2(FILE* file,EIF_INTEGER* o);
void se_prinT3(FILE* file,EIF_CHARACTER* o);
void se_prinT4(FILE* file,EIF_REAL_32* o);
void se_prinT5(FILE* file,EIF_REAL_64* o);
void se_prinT12(FILE* file,EIF_REAL_EXTENDED* o);
void se_prinT6(FILE* file,EIF_BOOLEAN* o);
void se_prinT7(FILE* file,EIF_STRING* o);
void se_prinT8(FILE* file,EIF_POINTER* o);
void se_prinT10(FILE* file,EIF_INTEGER_16* o);
void se_prinT11(FILE* file,EIF_INTEGER_64* o);

/*
   This type is used to store a position in some Eiffel source file.
   It must be compatible with the implementation of class POSITION.
*/
typedef unsigned int se_position;

#define se_position2line(position) (((position) & 1) \
  ? ((EIF_INTEGER)(((position) >> 1) & 0x7FFF)) \
  : ((EIF_INTEGER)(((position) >> 8) & 0x1FFF)))

#define se_position2column(position) (((position) & 1) \
  ? 0 \
  : ((EIF_INTEGER)(((position) >> 1) & 0x7F)))

#define se_position2path_id(position) (((position) & 1) \
  ? ((position) >> 17) \
  : ((position) >> 21))

/*
  To be able to print a stack frame in a human readable format :
*/
typedef struct _se_frame_descriptor se_frame_descriptor;
struct _se_frame_descriptor {
  char* name; /* Eiffel name of the routine. */
  int use_current; /* Flag is 1 when this routine use Current. */
  int local_count; /* Number of C variables to print. */
  char* local_format; /* Format/type information. */
  int assertion_flag; /* 1 when assertions can be checked. */
};

/* For flat_check opion */
extern int assertion_depth;

/*
  To keep the track of execution in order to be able to print a
  dump when things goes wrong :
*/
typedef struct _se_dump_stack se_dump_stack;
struct _se_dump_stack {
  se_frame_descriptor* fd;
  void* current; /* NULL when not used. */
  se_position p; /* The current position. */
  se_dump_stack* caller; /* Back to the caller. */
  se_dump_stack* exception_origin; /* The exception origin if we are handling an exception. That object was malloc'ed */
  void*** locals;
};
extern se_dump_stack* se_dst;
int se_stack_size(se_dump_stack* ds);
void se_print_run_time_stack(void);
int se_print_one_frame(se_dump_stack*ds);
int se_print_one_frame_in(FILE* file, se_dump_stack*ds);

int se_rci(se_dump_stack*caller,void*C);
void error0(char*m,char*vv);
void error1(char*m,se_position position);
void error2(T0* o,se_position position);
T0* vc(T0* o, se_position position);
T0* se_string_inspect_check(T0* o, se_position position);
T0* ci(int id, T0* o, se_position position);
void ac_req(int v, char* vv);
void ac_ens(int v, char* vv);
void ac_inv(int v, char* vv);
void ac_liv(int v, char* vv);
void ac_insp(int v);
int ac_lvc(int lc,int lv1,int lv2);
void ac_civ(int v,char*vv);
T0* se_evobt(T0* o,se_position position);
void se_signal_handler(int sig);
void se_gc_check_id(void*o,int id);

/* The two following instructions are used by the exceptions system to keep
   the stack trace when jumping back to the retry clause */
se_dump_stack* se_new_dump_stack(se_dump_stack* copy);
void se_delete_dump_stack(se_dump_stack* ds);

#ifndef SE_TRACE
#    define set_dump_stack_top(ds) se_dst=(ds)
#else
#    define set_dump_stack_top(ds) \
       do { \
         se_print_call_trace(ds); \
         se_dst=(ds); \
       } while(0);
#endif
#define FSOC_SIZE 8192
#define RSOC_SIZE 32768
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
   This file (SmartEiffel/sys/runtime/gc_lib.h) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has
   been selected).
*/

#define SE_GC_LIB 1

#define SE_GC_LOW_MEMORY_STRATEGY 0
#define SE_GC_HIGH_MEMORY_STRATEGY 1
#define SE_GC_DEFAULT_MEMORY_STRATEGY 2
extern int se_gc_strategy;


#define RSOH_UNMARKED 15253
#define RSOH_FREE 1
#define RSOH_MARKED 2


#define FSOH_UNMARKED ((void *) 1)
#define FSOH_MARKED   ((void *) 2)

/* To codify the state and the type of some Memory Chunk, we are
   using the following definitions :
*/
#define FSO_FREE_CHUNK  (-2)
#define RSO_FREE_CHUNK  (-1)
#define RSO_USED_CHUNK  ( 0)
#define FSO_STORE_CHUNK ( 1)
#define FSO_USED_CHUNK  ( 2)
#define FREE_CHUNK(x) ((x)<0)

/* Minimum size for a store area in a ReSizable Objects Chunk :
 */
#define RSOC_MIN_STORE 512

/* The default channel used to print -gc_info flag information :
*/
#define SE_GCINFO SE_ERR

extern int collector_counter; /* MEMORY.collector_counter */

typedef struct s_mch mch; /* Memory Chunk Header. */
typedef struct s_fsoc fsoc; /* Fixed Size Objects Chunk. */
typedef union u_rsoh rsoh; /* ReSizable Object Header. */
typedef struct s_fll_rsoh fll_rsoh;
typedef struct s_rsoc rsoc; /* ReSizable Objects Chunk. */
typedef struct s_na_env na_env; /* Native Array ENVironment. */


struct s_mch{
  unsigned int size; /* In number of bytes (actual argument of malloc).*/
  int state_type; /* One value in : RSO_USED_CHUNK,
                     FREE_CHUNK, FSO_STORE_CHUNK, FSO_USED_CHUNK */
  void(*amfp)(mch*,void*); /* Align Mark Function Pointer. */
  void(*swfp)(mch*); /* SWeep Function Pointer. */
};

struct s_fsoc{
  mch header; /* Common header for fsoc and rsoc. */
  fsoc* next; /* The next one when in free list (fsocfl). */
  int count_minus_one;
  double first_object;
};

typedef struct _rso_header rso_header;

struct _rso_header{
    unsigned int size;
    int magic_flag;     /* RSOH_MARKED when used,
			   RSOH_FREE when free,
			   else RSOH_UNMARKED */
};

typedef union u_fso_header fso_header;

union u_fso_header{
  void* flag;
  void* next;/* accurately typed as gcXX* in actual fso headers */
};

union u_rsoh{
  rso_header header;
  double padding;
};

struct s_fll_rsoh {
  rso_header rsoh_field;
  fll_rsoh* nextflol;
};

struct s_rsoc{
  mch header; /* Common header for fsoc and rsoc. */
  unsigned int isize; /* Initial size (at malloc time) to detect split chunks. */
  rsoc* next; /* Next one when in free list (rsocfl) or in na_env->chunk_list. */
  fll_rsoh*free_list_of_large; /* Intra. free list. */
  na_env*nae;
  rsoh first_header;
};

struct s_na_env{
  unsigned int store_left;
  rsoh* store;
  rsoc*store_chunk;
  rsoc*chunk_list; /*List of chunks of that type that have a non-null free_list_of_large*/
  void (*gc_mark)(T0*);
  int space_used;
};

extern void**stack_bottom;
extern mch**gcmt;
extern int gcmt_max;
extern int gcmt_used;
extern int gc_is_off;
extern fsoc* fsocfl;
extern unsigned int fsoc_count;
extern unsigned int rsoc_count;
extern void*gcmt_tail_addr;

void gc_sweep(void);
void gc_mark(void* p);
mch* gc_find_chunk(void* p);
int gc_stack_size(void);
int garbage_delayed(void);
void gc_update_ceils(void);
char*new_na(na_env*nae,unsigned int size);
unsigned int fsocfl_count(void);
unsigned int rsocfl_count(void);
void gc_dispose_before_exit(void);
void mark_stack_and_registers (void);
fsoc* gc_fsoc_get1(void);
fsoc* gc_fsoc_get2(void);

int gc_memory_used(void);
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#include <errno.h>

#define text_file_read_open(p) (fopen(((char*)(p)),"r"))
#define text_file_write_open(p) (fopen(((char*)(p)),"w"))
#define text_file_write_append(p) (fopen(((char*)(p)),"a"))
#define text_file_read_write_open(p) (fopen(((char*)(p)),"r+"))
#define text_file_read_write_append(p) (fopen(((char*)(p)),"a+"))
#define binary_file_read_open(p) (fopen(((char*)(p)),"rb"))
#define binary_file_write_open(p) (fopen(((char*)(p)),"wb"))
#define binary_file_write_append(p) (fopen(((char*)(p)),"ab"))
#define io_fclose(p) (fclose((FILE*)(p)))
#define io_flush(p) (fflush((FILE*)(p)))
#define io_getc(f) (getc(((FILE*)(f))))
#define io_putc(b, f) (putc((b),((FILE*)(f))))
#define io_fread(b, n, f) (fread((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define io_fwrite(b, n, f) (fwrite((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define io_feof(f) (feof(((FILE*)(f))))
#define io_rename(o, n) (rename(((char*)(o)),((char*)(n))))
#define io_remove(f) (remove(((char*)(f))))
#define io_fseek(f, o) (fseek((FILE*)(f),(o),SEEK_SET))
#define io_ftell(f) ((EIF_INTEGER_64)ftell((FILE*)(f)))

#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  define read_stdin(b, s) (read(STDIN_FILENO, b, s))
#else
   extern int read_stdin(EIF_CHARACTER *buffer, int size);
#endif

extern void io_copy(char*source, char*target);
extern int io_file_exists(char*source);
extern int io_same_physical_file(char*path1,char*path2);
extern unsigned int fsoc_count_ceil;
extern unsigned int rsoc_count_ceil;
/*NATIVE_ARRAY[STRING]*/T6 r168all_default(se_dump_stack*caller,T168 C,T2 a1);
/*NATIVE_ARRAY[STRING]*/void r168clear_all(se_dump_stack*caller,T168 C,T2 a1);
/*NATIVE_ARRAY[STRING]*/void r168set_all_with(se_dump_stack*caller,T168 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/T168 r168realloc(se_dump_stack*caller,T168 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/void r168copy_from(se_dump_stack*caller,T168 C,T168 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/T6 r168fast_memcmp(se_dump_stack*caller,T168 C,T168 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/T6 r168is_not_null(se_dump_stack*caller,T168 C);
/*NATIVE_ARRAY[ADHERENT]*/T6 r183all_default(se_dump_stack*caller,T183 C,T2 a1);
/*NATIVE_ARRAY[ADHERENT]*/void r183clear_all(se_dump_stack*caller,T183 C,T2 a1);
/*NATIVE_ARRAY[ADHERENT]*/void r183set_all_with(se_dump_stack*caller,T183 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[ADHERENT]*/T183 r183realloc(se_dump_stack*caller,T183 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[ADHERENT]*/void r183copy_from(se_dump_stack*caller,T183 C,T183 a1,T2 a2);
/*NATIVE_ARRAY[ADHERENT]*/T6 r183is_not_null(se_dump_stack*caller,T183 C);
/*NATIVE_ARRAY[PERSONNEL]*/T6 r182all_default(se_dump_stack*caller,T182 C,T2 a1);
/*NATIVE_ARRAY[PERSONNEL]*/void r182clear_all(se_dump_stack*caller,T182 C,T2 a1);
/*NATIVE_ARRAY[PERSONNEL]*/void r182set_all_with(se_dump_stack*caller,T182 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[PERSONNEL]*/T182 r182realloc(se_dump_stack*caller,T182 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[PERSONNEL]*/void r182copy_from(se_dump_stack*caller,T182 C,T182 a1,T2 a2);
/*NATIVE_ARRAY[PERSONNEL]*/T6 r182is_not_null(se_dump_stack*caller,T182 C);
/*NATIVE_ARRAY[EMPRUNT]*/T6 r178all_default(se_dump_stack*caller,T178 C,T2 a1);
/*NATIVE_ARRAY[EMPRUNT]*/void r178clear_all(se_dump_stack*caller,T178 C,T2 a1);
/*NATIVE_ARRAY[EMPRUNT]*/void r178set_all_with(se_dump_stack*caller,T178 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[EMPRUNT]*/T6 r178is_not_null(se_dump_stack*caller,T178 C);
/*NATIVE_ARRAY[DVD]*/T6 r175all_default(se_dump_stack*caller,T175 C,T2 a1);
/*NATIVE_ARRAY[DVD]*/void r175clear_all(se_dump_stack*caller,T175 C,T2 a1);
/*NATIVE_ARRAY[DVD]*/void r175set_all_with(se_dump_stack*caller,T175 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[DVD]*/T175 r175realloc(se_dump_stack*caller,T175 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[DVD]*/void r175copy_from(se_dump_stack*caller,T175 C,T175 a1,T2 a2);
/*NATIVE_ARRAY[DVD]*/T6 r175is_not_null(se_dump_stack*caller,T175 C);
/*NATIVE_ARRAY[LIVRE]*/T6 r174all_default(se_dump_stack*caller,T174 C,T2 a1);
/*NATIVE_ARRAY[LIVRE]*/void r174clear_all(se_dump_stack*caller,T174 C,T2 a1);
/*NATIVE_ARRAY[LIVRE]*/void r174set_all_with(se_dump_stack*caller,T174 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[LIVRE]*/T174 r174realloc(se_dump_stack*caller,T174 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LIVRE]*/void r174copy_from(se_dump_stack*caller,T174 C,T174 a1,T2 a2);
/*NATIVE_ARRAY[LIVRE]*/T6 r174is_not_null(se_dump_stack*caller,T174 C);
/*STD_OUTPUT*/T6 r47can_put_character(se_dump_stack*caller,T47* C,T3 a1);
/*STD_OUTPUT*/void r47filtered_flush(se_dump_stack*caller,T47* C);
/*STD_OUTPUT*/void r47filtered_put_character(se_dump_stack*caller,T47* C,T3 a1);
extern T0*oBC13std_output;
extern int fBC13std_output;
/*STD_OUTPUT*/T0* r47std_output(se_dump_stack*caller,T47* C);
/*STD_OUTPUT*/void r47se_atexit(se_dump_stack*caller,T47* C);
/*STD_OUTPUT*/void r47make(se_dump_stack*caller,T47* C);
/*STD_OUTPUT*/T6 r47is_filtered(se_dump_stack*caller,T47* C);
/*STD_OUTPUT*/void r47write_buffer(se_dump_stack*caller,T47* C);
/*STD_OUTPUT*/void r47put_character(se_dump_stack*caller,T47* C,T3 a1);
/*STD_OUTPUT*/void r47flush(se_dump_stack*caller,T47* C);
/*STD_INPUT*/void r48read_character(se_dump_stack*caller,T48* C);
/*STD_INPUT*/T6 r48can_unread_character(se_dump_stack*caller,T48* C);
/*STD_INPUT*/T0* r48std_output(se_dump_stack*caller,T48* C);
/*STD_INPUT*/T3 r48last_character(se_dump_stack*caller,T48* C);
/*STD_INPUT*/void r48unread_character(se_dump_stack*caller,T48* C);
/*STD_INPUT*/T3 r48filtered_last_character(se_dump_stack*caller,T48* C);
/*STD_INPUT*/void r48make(se_dump_stack*caller,T48* C);
/*STD_INPUT*/void r48filtered_read_character(se_dump_stack*caller,T48* C);
/*STD_INPUT*/void r48filtered_unread_character(se_dump_stack*caller,T48* C);
/*STD_INPUT*/T6 r48is_filtered(se_dump_stack*caller,T48* C);
/*STD_INPUT*/void r48fill_buffer(se_dump_stack*caller,T48* C);
/*INTEGER_64*/T6 r11is_equal(se_dump_stack*caller,T11 C,T11 a1);
/*INTEGER_64*/T11 r11_ix_43(se_dump_stack*caller,T11 C,T11 a1);
/*INTEGER_64*/T11 r11abs(se_dump_stack*caller,T11 C);
/*INTEGER_64*/T3 r11decimal_digit(se_dump_stack*caller,T11 C);
/*INTEGER_64*/T6 r11in_range(se_dump_stack*caller,T11 C,T11 a1,T11 a2);
/*INTEGER_64*/T2 r11hash_code(se_dump_stack*caller,T11 C);
/*INTEGER_64*/void r11append_in(se_dump_stack*caller,T11 C,T0* a1);
/*INTEGER_64*/T2 r11to_integer_32(se_dump_stack*caller,T11 C);
/*INTEGER_64*/T6 r11fit_integer_32(se_dump_stack*caller,T11 C);
/*INTEGER_64*/T6 r11divisible(se_dump_stack*caller,T11 a1);
/*INTEGER_64*/T11 r11_ix_42(se_dump_stack*caller,T11 C,T11 a1);
/*INTEGER_64*/T11 r11_px_45(se_dump_stack*caller,T11 C);
/*INTEGER_64*/T11 r11_ix_45(se_dump_stack*caller,T11 C,T11 a1);
/*ARRAY[STRING]*/T6 r167is_equal(se_dump_stack*caller,T167* C,T0* a1);
/*ARRAY[STRING]*/void r167put(se_dump_stack*caller,T167* C,T0* a1,T2 a2);
/*ARRAY[STRING]*/void r167copy(se_dump_stack*caller,T167* C,T0* a1);
/*ARRAY[STRING]*/void r167mark_native_arrays(se_dump_stack*caller,T167* C);
/*ARRAY[STRING]*/T0* r167twin(se_dump_stack*caller,T167* C);
/*ARRAY[STRING]*/T6 r167all_default(se_dump_stack*caller,T167* C);
/*ARRAY[STRING]*/void r167clear_count(se_dump_stack*caller,T167* C);
/*ARRAY[STRING]*/void r167clear_all(se_dump_stack*caller,T167* C);
/*ARRAY[STRING]*/void r167set_all_with(se_dump_stack*caller,T167* C,T0* a1);
/*ARRAY[STRING]*/void r167ensure_capacity_and_bounds(se_dump_stack*caller,T167* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[STRING]*/void r167add_last(se_dump_stack*caller,T167* C,T0* a1);
/*ARRAY[STRING]*/void r167with_capacity(se_dump_stack*caller,T167* C,T2 a1,T2 a2);
/*ARRAY[STRING]*/T2 r167count(se_dump_stack*caller,T167* C);
/*ARRAY[STRING]*/T0* r167last(se_dump_stack*caller,T167* C);
/*ARRAY[STRING]*/T6 r167valid_index(se_dump_stack*caller,T167* C,T2 a1);
/*ARRAY[STRING]*/T6 r167is_empty(se_dump_stack*caller,T167* C);
/*ARRAY[STRING]*/T0* r167item(se_dump_stack*caller,T167* C,T2 a1);
extern se_frame_descriptor se_ifd167;
T167*se_i167(se_dump_stack*caller,T167*C);
/*ADHERENT*/T6 r49is_default(se_dump_stack*caller,T49* C);
/*ADHERENT*/T0* r49default(se_dump_stack*caller,T49* C);
/*ADHERENT*/void r49set_id(se_dump_stack*caller,T49* C,T0* a1);
/*ADHERENT*/void r49make(se_dump_stack*caller,T49* C,T0* a1,T0* a2,T0* a3,T0* a4,T0* a5);
/*ADHERENT*/void r49set_date_naiss(se_dump_stack*caller,T49* C,T0* a1);
/*ADHERENT*/void r49set_adresse(se_dump_stack*caller,T49* C,T0* a1);
/*ADHERENT*/void r49set_prenom(se_dump_stack*caller,T49* C,T0* a1);
/*ADHERENT*/void r49set_nom(se_dump_stack*caller,T49* C,T0* a1);
/*ARRAY[ADHERENT]*/void r180put(se_dump_stack*caller,T180* C,T0* a1,T2 a2);
/*ARRAY[ADHERENT]*/void r180mark_native_arrays(se_dump_stack*caller,T180* C);
/*ARRAY[ADHERENT]*/T6 r180all_default(se_dump_stack*caller,T180* C);
/*ARRAY[ADHERENT]*/void r180clear_all(se_dump_stack*caller,T180* C);
/*ARRAY[ADHERENT]*/void r180set_all_with(se_dump_stack*caller,T180* C,T0* a1);
/*ARRAY[ADHERENT]*/void r180ensure_capacity_and_bounds(se_dump_stack*caller,T180* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[ADHERENT]*/void r180add_last(se_dump_stack*caller,T180* C,T0* a1);
/*ARRAY[ADHERENT]*/void r180with_capacity(se_dump_stack*caller,T180* C,T2 a1,T2 a2);
/*ARRAY[ADHERENT]*/T2 r180count(se_dump_stack*caller,T180* C);
/*ARRAY[ADHERENT]*/T0* r180last(se_dump_stack*caller,T180* C);
/*ARRAY[ADHERENT]*/T6 r180valid_index(se_dump_stack*caller,T180* C,T2 a1);
/*ARRAY[ADHERENT]*/T6 r180is_empty(se_dump_stack*caller,T180* C);
/*ARRAY[ADHERENT]*/T0* r180item(se_dump_stack*caller,T180* C,T2 a1);
extern se_frame_descriptor se_ifd180;
T180*se_i180(se_dump_stack*caller,T180*C);
/*ARRAY[PERSONNEL]*/void r179put(se_dump_stack*caller,T179* C,T0* a1,T2 a2);
/*ARRAY[PERSONNEL]*/void r179mark_native_arrays(se_dump_stack*caller,T179* C);
/*ARRAY[PERSONNEL]*/T6 r179all_default(se_dump_stack*caller,T179* C);
/*ARRAY[PERSONNEL]*/void r179clear_all(se_dump_stack*caller,T179* C);
/*ARRAY[PERSONNEL]*/void r179set_all_with(se_dump_stack*caller,T179* C,T0* a1);
/*ARRAY[PERSONNEL]*/void r179ensure_capacity_and_bounds(se_dump_stack*caller,T179* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[PERSONNEL]*/void r179add_last(se_dump_stack*caller,T179* C,T0* a1);
/*ARRAY[PERSONNEL]*/void r179with_capacity(se_dump_stack*caller,T179* C,T2 a1,T2 a2);
/*ARRAY[PERSONNEL]*/T2 r179count(se_dump_stack*caller,T179* C);
/*ARRAY[PERSONNEL]*/T0* r179last(se_dump_stack*caller,T179* C);
/*ARRAY[PERSONNEL]*/T6 r179valid_index(se_dump_stack*caller,T179* C,T2 a1);
/*ARRAY[PERSONNEL]*/T6 r179is_empty(se_dump_stack*caller,T179* C);
/*ARRAY[PERSONNEL]*/T0* r179item(se_dump_stack*caller,T179* C,T2 a1);
extern se_frame_descriptor se_ifd179;
T179*se_i179(se_dump_stack*caller,T179*C);
/*PERSONNEL*/T6 r169is_default(se_dump_stack*caller,T169* C);
/*PERSONNEL*/T0* r169get_id(se_dump_stack*caller,T169* C);
/*PERSONNEL*/T0* r169default(se_dump_stack*caller,T169* C);
/*PERSONNEL*/void r169set_id(se_dump_stack*caller,T169* C,T0* a1);
/*PERSONNEL*/void r169make(se_dump_stack*caller,T169* C,T0* a1,T0* a2,T0* a3,T0* a4,T0* a5,T0* a6);
/*PERSONNEL*/void r169set_date_naiss(se_dump_stack*caller,T169* C,T0* a1);
/*PERSONNEL*/T0* r169get_nom(se_dump_stack*caller,T169* C);
/*PERSONNEL*/void r169set_adresse(se_dump_stack*caller,T169* C,T0* a1);
/*PERSONNEL*/void r169set_prenom(se_dump_stack*caller,T169* C,T0* a1);
/*PERSONNEL*/void r169set_nom(se_dump_stack*caller,T169* C,T0* a1);
/*PERSONNEL*/void r169make_adherent(se_dump_stack*caller,T169* C,T0* a1,T0* a2,T0* a3,T0* a4,T0* a5);
/*PERSONNEL*/void r169set_matricule(se_dump_stack*caller,T169* C,T0* a1);
/*EMPRUNT*/T6 r176is_default(se_dump_stack*caller,T176* C);
/*EMPRUNT*/T0* r176default(se_dump_stack*caller,T176* C);
/*EMPRUNT*/void r176affichage_test(se_dump_stack*caller,T176* C);
extern T0*oBC13io;
extern int fBC13io;
/*EMPRUNT*/T0* r176io(se_dump_stack*caller,T176* C);
/*EMPRUNT*/void r176make(se_dump_stack*caller,T176* C,T0* a1,T0* a2,T0* a3,T0* a4,T0* a5);
/*EMPRUNT*/T0* r176get_id_adh(se_dump_stack*caller,T176* C);
/*EMPRUNT*/void r176set_date_retour_r(se_dump_stack*caller,T176* C,T0* a1);
/*EMPRUNT*/T0* r176get_id_media(se_dump_stack*caller,T176* C);
/*ARRAY[EMPRUNT]*/void r177put(se_dump_stack*caller,T177* C,T0* a1,T2 a2);
/*ARRAY[EMPRUNT]*/void r177mark_native_arrays(se_dump_stack*caller,T177* C);
/*ARRAY[EMPRUNT]*/T6 r177all_default(se_dump_stack*caller,T177* C);
/*ARRAY[EMPRUNT]*/void r177clear_all(se_dump_stack*caller,T177* C);
/*ARRAY[EMPRUNT]*/void r177set_all_with(se_dump_stack*caller,T177* C,T0* a1);
/*ARRAY[EMPRUNT]*/void r177ensure_capacity_and_bounds(se_dump_stack*caller,T177* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[EMPRUNT]*/void r177with_capacity(se_dump_stack*caller,T177* C,T2 a1,T2 a2);
/*ARRAY[EMPRUNT]*/T2 r177count(se_dump_stack*caller,T177* C);
/*ARRAY[EMPRUNT]*/T6 r177valid_index(se_dump_stack*caller,T177* C,T2 a1);
/*ARRAY[EMPRUNT]*/T6 r177is_empty(se_dump_stack*caller,T177* C);
/*ARRAY[EMPRUNT]*/T0* r177item(se_dump_stack*caller,T177* C,T2 a1);
extern se_frame_descriptor se_ifd177;
T177*se_i177(se_dump_stack*caller,T177*C);
/*DVD*/T6 r125is_default(se_dump_stack*caller,T125* C);
/*DVD*/void r125augmenter_exemplaires(se_dump_stack*caller,T125* C);
/*DVD*/T0* r125get_id(se_dump_stack*caller,T125* C);
/*DVD*/T0* r125get_titre(se_dump_stack*caller,T125* C);
/*DVD*/void r125diminuer_exemplaires(se_dump_stack*caller,T125* C);
/*DVD*/T0* r125default(se_dump_stack*caller,T125* C);
/*DVD*/void r125make_media(se_dump_stack*caller,T125* C,T0* a1,T0* a2,T0* a3,T2 a4,T0* a5);
/*DVD*/void r125affichage_test(se_dump_stack*caller,T125* C);
/*DVD*/T0* r125io(se_dump_stack*caller,T125* C);
/*DVD*/void r125make(se_dump_stack*caller,T125* C,T0* a1,T0* a2,T0* a3,T2 a4,T0* a5,T0* a6,T0* a7,T0* a8);
/*ARRAY[DVD]*/void r173put(se_dump_stack*caller,T173* C,T0* a1,T2 a2);
/*ARRAY[DVD]*/void r173mark_native_arrays(se_dump_stack*caller,T173* C);
/*ARRAY[DVD]*/void r173move(se_dump_stack*caller,T173* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[DVD]*/T6 r173all_default(se_dump_stack*caller,T173* C);
/*ARRAY[DVD]*/void r173clear_all(se_dump_stack*caller,T173* C);
/*ARRAY[DVD]*/void r173set_all_with(se_dump_stack*caller,T173* C,T0* a1);
/*ARRAY[DVD]*/void r173add_first(se_dump_stack*caller,T173* C,T0* a1);
/*ARRAY[DVD]*/void r173ensure_capacity_and_bounds(se_dump_stack*caller,T173* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[DVD]*/void r173add_last(se_dump_stack*caller,T173* C,T0* a1);
/*ARRAY[DVD]*/void r173with_capacity(se_dump_stack*caller,T173* C,T2 a1,T2 a2);
/*ARRAY[DVD]*/T2 r173count(se_dump_stack*caller,T173* C);
/*ARRAY[DVD]*/T0* r173first(se_dump_stack*caller,T173* C);
/*ARRAY[DVD]*/T0* r173last(se_dump_stack*caller,T173* C);
/*ARRAY[DVD]*/T6 r173valid_index(se_dump_stack*caller,T173* C,T2 a1);
/*ARRAY[DVD]*/T6 r173is_empty(se_dump_stack*caller,T173* C);
/*ARRAY[DVD]*/T0* r173item(se_dump_stack*caller,T173* C,T2 a1);
extern se_frame_descriptor se_ifd173;
T173*se_i173(se_dump_stack*caller,T173*C);
/*INTEGER_16*/T6 r10is_equal(se_dump_stack*caller,T10 C,T10 a1);
/*INTEGER_16*/T10 r10_ix_43(se_dump_stack*caller,T10 C,T10 a1);
/*INTEGER_16*/T6 r10in_range(se_dump_stack*caller,T10 C,T10 a1,T10 a2);
/*INTEGER_16*/T2 r10hash_code(se_dump_stack*caller,T10 C);
/*INTEGER_16*/T6 r10fit_integer_8(se_dump_stack*caller,T10 C);
/*INTEGER_16*/T1 r10to_integer_8(se_dump_stack*caller,T10 C);
/*INTEGER_16*/T10 r10_ix_45(se_dump_stack*caller,T10 C,T10 a1);
/*LIVRE*/T6 r123is_default(se_dump_stack*caller,T123* C);
/*LIVRE*/T0* r123get_id(se_dump_stack*caller,T123* C);
/*LIVRE*/T0* r123get_titre(se_dump_stack*caller,T123* C);
/*LIVRE*/T0* r123default(se_dump_stack*caller,T123* C);
/*LIVRE*/void r123make_media(se_dump_stack*caller,T123* C,T0* a1,T0* a2,T0* a3,T2 a4,T0* a5);
/*LIVRE*/void r123affichage_test(se_dump_stack*caller,T123* C);
/*LIVRE*/T0* r123io(se_dump_stack*caller,T123* C);
/*LIVRE*/void r123make(se_dump_stack*caller,T123* C,T0* a1,T0* a2,T0* a3,T2 a4,T0* a5,T0* a6,T2 a7);
/*ARRAY[LIVRE]*/void r172put(se_dump_stack*caller,T172* C,T0* a1,T2 a2);
/*ARRAY[LIVRE]*/void r172mark_native_arrays(se_dump_stack*caller,T172* C);
/*ARRAY[LIVRE]*/T6 r172all_default(se_dump_stack*caller,T172* C);
/*ARRAY[LIVRE]*/void r172clear_all(se_dump_stack*caller,T172* C);
/*ARRAY[LIVRE]*/void r172set_all_with(se_dump_stack*caller,T172* C,T0* a1);
/*ARRAY[LIVRE]*/void r172ensure_capacity_and_bounds(se_dump_stack*caller,T172* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[LIVRE]*/void r172add_last(se_dump_stack*caller,T172* C,T0* a1);
/*ARRAY[LIVRE]*/void r172with_capacity(se_dump_stack*caller,T172* C,T2 a1,T2 a2);
/*ARRAY[LIVRE]*/T2 r172count(se_dump_stack*caller,T172* C);
/*ARRAY[LIVRE]*/T0* r172last(se_dump_stack*caller,T172* C);
/*ARRAY[LIVRE]*/T6 r172valid_index(se_dump_stack*caller,T172* C,T2 a1);
/*ARRAY[LIVRE]*/T6 r172is_empty(se_dump_stack*caller,T172* C);
/*ARRAY[LIVRE]*/T0* r172item(se_dump_stack*caller,T172* C,T2 a1);
extern se_frame_descriptor se_ifd172;
T172*se_i172(se_dump_stack*caller,T172*C);
/*TEXT_FILE_READ*/void r58read_line_in(se_dump_stack*caller,T58* C,T0* a1);
/*TEXT_FILE_READ*/void r58read_line(se_dump_stack*caller,T58* C);
extern T0*oBC44last_string;
extern int fBC44last_string;
/*TEXT_FILE_READ*/T0* r58last_string(se_dump_stack*caller,T58* C);
/*TEXT_FILE_READ*/T3 r58filtered_last_character(se_dump_stack*caller,T58* C);
/*TEXT_FILE_READ*/void r58make(se_dump_stack*caller,T58* C);
/*TEXT_FILE_READ*/void r58filtered_read_line_in(se_dump_stack*caller,T58* C,T0* a1);
/*TEXT_FILE_READ*/void r58connect_to(se_dump_stack*caller,T58* C,T0* a1);
/*TEXT_FILE_READ*/void r58disconnect(se_dump_stack*caller,T58* C);
/*TEXT_FILE_READ*/T6 r58is_filtered(se_dump_stack*caller,T58* C);
/*TEXT_FILE_READ*/T6 r58is_connected(se_dump_stack*caller,T58* C);
/*TEXT_FILE_READ*/void r58fill_buffer(se_dump_stack*caller,T58* C);
/*STD_INPUT_OUTPUT*/T6 r40can_put_character(se_dump_stack*caller,T40* C,T3 a1);
/*STD_INPUT_OUTPUT*/void r40read_character(se_dump_stack*caller,T40* C);
extern T0*oBC13std_input;
extern int fBC13std_input;
/*STD_INPUT_OUTPUT*/T0* r40std_input(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T6 r40can_unread_character(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40read_line_in(se_dump_stack*caller,T40* C,T0* a1);
/*STD_INPUT_OUTPUT*/T6 r40end_of_input(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40filtered_flush(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T0* r40std_output(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40filtered_put_character(se_dump_stack*caller,T40* C,T3 a1);
/*STD_INPUT_OUTPUT*/void r40read_integer(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T3 r40last_character(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40read_line(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40unread_character(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T0* r40last_string(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T3 r40filtered_last_character(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40make(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40filtered_read_line_in(se_dump_stack*caller,T40* C,T0* a1);
/*STD_INPUT_OUTPUT*/void r40filtered_read_character(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40filtered_unread_character(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T6 r40input_is_filtered(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T6 r40output_is_filtered(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T6 r40is_connected(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40put_character(se_dump_stack*caller,T40* C,T3 a1);
/*STD_INPUT_OUTPUT*/void r40flush(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40put_string(se_dump_stack*caller,T40* C,T0* a1);
/*STD_INPUT_OUTPUT*/void r40put_integer(se_dump_stack*caller,T40* C,T11 a1);
extern T0*oBC30tmp_string;
extern int fBC30tmp_string;
/*STD_INPUT_OUTPUT*/T0* r40tmp_string(se_dump_stack*caller,T40* C);
extern se_frame_descriptor se_ifd40;
T40*se_i40(se_dump_stack*caller,T40*C);
/*POINTER*/T6 r8is_null(se_dump_stack*caller,T8 C);
/*BOOLEAN*/T6 r6_ix_and(se_dump_stack*caller,T6 C,T6 a1);
/*BOOLEAN*/T6 r6_px_not(se_dump_stack*caller,T6 C);
/*BOOLEAN*/T6 r6_ix_or(se_dump_stack*caller,T6 C,T6 a1);
/*INTEGER_8*/T6 r1is_equal(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/T6 r1in_range(se_dump_stack*caller,T1 C,T1 a1,T1 a2);
/*INTEGER_8*/T2 r1hash_code(se_dump_stack*caller,T1 C);
/*INTEGER_8*/T1 r1_ix_45(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_32*/T6 r2is_equal(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2_ix_43(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2abs(se_dump_stack*caller,T2 C);
/*INTEGER_32*/T2 r2compare(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2min(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2max(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2hash_code(se_dump_stack*caller,T2 C);
/*INTEGER_32*/T6 r2divisible(se_dump_stack*caller,T2 a1);
/*INTEGER_32*/T2 r2_ix_42(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2_px_45(se_dump_stack*caller,T2 C);
/*INTEGER_32*/T2 r2_ix_45(se_dump_stack*caller,T2 C,T2 a1);
/*MEDIATHEQUE*/T0* r25io(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/void r25creation_adh_with_file(se_dump_stack*caller,T25* C,T0* a1);
/*MEDIATHEQUE*/T6 r25augmenter_exemplaire_media(se_dump_stack*caller,T25* C,T0* a1);
/*MEDIATHEQUE*/void r25rendre_emprunt(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/void r25instance_test(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/void r25enregistrer_emprunt(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/void r25consulte_emprunt(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/void r25recherche_dvd(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/void r25main(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/void r25menu_adh(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/void r25recherche_livre(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/T6 r25diminuer_exemplaire_media(se_dump_stack*caller,T25* C,T0* a1);
/*MEDIATHEQUE*/void r25menu_personnel(se_dump_stack*caller,T25* C);
/*CHARACTER*/T6 r3is_equal(se_dump_stack*caller,T3 C,T3 a1);
/*CHARACTER*/T6 r3is_default(se_dump_stack*caller,T3 C);
/*CHARACTER*/T3 r3default(se_dump_stack*caller);
/*CHARACTER*/T6 r3_ix_6261(se_dump_stack*caller,T3 C,T3 a1);
/*CHARACTER*/T6 r3_ix_60(se_dump_stack*caller,T3 C,T3 a1);
/*CHARACTER*/T6 r3in_range(se_dump_stack*caller,T3 C,T3 a1,T3 a2);
/*CHARACTER*/T6 r3_ix_6061(se_dump_stack*caller,T3 C,T3 a1);
/*CHARACTER*/T2 r3hash_code(se_dump_stack*caller,T3 C);
/*CHARACTER*/T3 r3to_upper(se_dump_stack*caller,T3 C);
/*CHARACTER*/T6 r3is_digit(se_dump_stack*caller,T3 C);
/*CHARACTER*/T1 r3value(se_dump_stack*caller,T3 C);
/*CHARACTER*/T6 r3is_separator(se_dump_stack*caller,T3 C);
/*CHARACTER*/T3 r3to_lower(se_dump_stack*caller,T3 C);
/*CHARACTER*/T6 r3same_as(se_dump_stack*caller,T3 C,T3 a1);
/*NATIVE_ARRAY[CHARACTER]*/T2 r9fast_occurrences(se_dump_stack*caller,T9 C,T3 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9fast_replace_all(se_dump_stack*caller,T9 C,T3 a1,T3 a2,T2 a3);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9all_default(se_dump_stack*caller,T9 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/void r9clear_all(se_dump_stack*caller,T9 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9fast_has(se_dump_stack*caller,T9 C,T3 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/T9 r9realloc(se_dump_stack*caller,T9 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9copy_from(se_dump_stack*caller,T9 C,T9 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9clear(se_dump_stack*caller,T9 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9copy_at(se_dump_stack*caller,T9 C,T2 a1,T9 a2,T2 a3);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9fast_memcmp(se_dump_stack*caller,T9 C,T9 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9slice_copy(se_dump_stack*caller,T9 C,T2 a1,T9 a2,T2 a3,T2 a4);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9is_not_null(se_dump_stack*caller,T9 C);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9is_null(se_dump_stack*caller,T9 C);
/*STRING*/T6 r7is_equal(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/T6 r7is_default(se_dump_stack*caller,T7* C);
/*STRING*/void r7put(se_dump_stack*caller,T7* C,T3 a1,T2 a2);
/*STRING*/void r7copy(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/T0* r7_ix_43(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/T0* r7default(se_dump_stack*caller,T7* C);
extern T0*oBC7string_buffer;
extern int fBC7string_buffer;
/*STRING*/T0* r7string_buffer(se_dump_stack*caller,T7* C);
extern T0*oBC7split_buffer;
extern int fBC7split_buffer;
/*STRING*/T0* r7split_buffer(se_dump_stack*caller,T7* C);
/*STRING*/T0* r7split(se_dump_stack*caller,T7* C);
/*STRING*/void r7append(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/void r7replace_all(se_dump_stack*caller,T7* C,T3 a1,T3 a2);
/*STRING*/void r7set_count(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/T0* r7twin(se_dump_stack*caller,T7* C);
/*STRING*/void r7make(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/void r7clear_count(se_dump_stack*caller,T7* C);
/*STRING*/T6 r7_ix_60(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/void r7extend(se_dump_stack*caller,T7* C,T3 a1);
/*STRING*/void r7remove_last(se_dump_stack*caller,T7* C);
/*STRING*/T2 r7hash_code(se_dump_stack*caller,T7* C);
/*STRING*/T6 r7has(se_dump_stack*caller,T7* C,T3 a1);
/*STRING*/void r7add_last(se_dump_stack*caller,T7* C,T3 a1);
/*STRING*/void r7resize(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/void r7ensure_capacity(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/T6 r7same_as(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/T8 r7to_external(se_dump_stack*caller,T7* C);
/*STRING*/T2 r7count(se_dump_stack*caller,T7* C);
/*STRING*/void r7split_in(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/T2 r7upper(se_dump_stack*caller,T7* C);
/*STRING*/void r7swap(se_dump_stack*caller,T7* C,T2 a1,T2 a2);
/*STRING*/T3 r7last(se_dump_stack*caller,T7* C);
/*STRING*/T6 r7valid_index(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/T6 r7is_empty(se_dump_stack*caller,T7* C);
/*STRING*/T3 r7item(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/T2 r7occurrences(se_dump_stack*caller,T7* C,T3 a1);
extern se_frame_descriptor se_ifd7;
T7*se_i7(se_dump_stack*caller,T7*C);
extern T0*ms53_117797837;
T0*se_ms(int c,char*e);
T0*se_string(char*e);
void se_msi1(void);
void manifest_string_mark1(void);
void once_function_mark(void);
void gc_start(void);
extern na_env na_env168;
extern na_env na_env183;
extern na_env na_env182;
extern na_env na_env178;
extern na_env na_env175;
extern na_env na_env174;
typedef struct B47 gc47;
struct B47{T47 object;union {void*flag;gc47*next;} header;};
extern gc47*store47;
extern int store_left47;
extern fsoc*store_chunk47;
extern gc47*gc_free47;
typedef struct B48 gc48;
struct B48{T48 object;union {void*flag;gc48*next;} header;};
extern gc48*store48;
extern int store_left48;
extern fsoc*store_chunk48;
extern gc48*gc_free48;
typedef struct B167 gc167;
struct B167{T167 object;union {void*flag;gc167*next;} header;};
extern gc167*store167;
extern int store_left167;
extern fsoc*store_chunk167;
extern gc167*gc_free167;
typedef struct B49 gc49;
struct B49{T49 object;union {void*flag;gc49*next;} header;};
extern gc49*store49;
extern int store_left49;
extern fsoc*store_chunk49;
extern gc49*gc_free49;
typedef struct B180 gc180;
struct B180{T180 object;union {void*flag;gc180*next;} header;};
extern gc180*store180;
extern int store_left180;
extern fsoc*store_chunk180;
extern gc180*gc_free180;
typedef struct B179 gc179;
struct B179{T179 object;union {void*flag;gc179*next;} header;};
extern gc179*store179;
extern int store_left179;
extern fsoc*store_chunk179;
extern gc179*gc_free179;
typedef struct B169 gc169;
struct B169{T169 object;union {void*flag;gc169*next;} header;};
extern gc169*store169;
extern int store_left169;
extern fsoc*store_chunk169;
extern gc169*gc_free169;
typedef struct B176 gc176;
struct B176{T176 object;union {void*flag;gc176*next;} header;};
extern gc176*store176;
extern int store_left176;
extern fsoc*store_chunk176;
extern gc176*gc_free176;
typedef struct B177 gc177;
struct B177{T177 object;union {void*flag;gc177*next;} header;};
extern gc177*store177;
extern int store_left177;
extern fsoc*store_chunk177;
extern gc177*gc_free177;
typedef struct B125 gc125;
struct B125{T125 object;union {void*flag;gc125*next;} header;};
extern gc125*store125;
extern int store_left125;
extern fsoc*store_chunk125;
extern gc125*gc_free125;
typedef struct B173 gc173;
struct B173{T173 object;union {void*flag;gc173*next;} header;};
extern gc173*store173;
extern int store_left173;
extern fsoc*store_chunk173;
extern gc173*gc_free173;
typedef struct B123 gc123;
struct B123{T123 object;union {void*flag;gc123*next;} header;};
extern gc123*store123;
extern int store_left123;
extern fsoc*store_chunk123;
extern gc123*gc_free123;
typedef struct B172 gc172;
struct B172{T172 object;union {void*flag;gc172*next;} header;};
extern gc172*store172;
extern int store_left172;
extern fsoc*store_chunk172;
extern gc172*gc_free172;
typedef struct B58 gc58;
struct B58{T58 object;union {void*flag;gc58*next;} header;};
extern gc58*store58;
extern int store_left58;
extern fsoc*store_chunk58;
extern gc58*gc_free58;
typedef struct B40 gc40;
struct B40{T40 object;union {void*flag;gc40*next;} header;};
extern gc40*store40;
extern int store_left40;
extern fsoc*store_chunk40;
extern gc40*gc_free40;
typedef struct B25 gc25;
struct B25{T25 object;union {void*flag;gc25*next;} header;};
extern gc25*store25;
extern int store_left25;
extern fsoc*store_chunk25;
extern gc25*gc_free25;
extern na_env na_env9;
typedef struct B7 gc7;
struct B7{T7 object;union {void*flag;gc7*next;} header;};
extern gc7*store7;
extern int store_left7;
extern fsoc*store_chunk7;
extern gc7*gc_free7;
void gc_mark168(T168 o);
T168 new168(unsigned int size);
void gc_mark183(T183 o);
T183 new183(unsigned int size);
void gc_mark182(T182 o);
T182 new182(unsigned int size);
void gc_mark178(T178 o);
T178 new178(unsigned int size);
void gc_mark175(T175 o);
T175 new175(unsigned int size);
void gc_mark174(T174 o);
T174 new174(unsigned int size);
void gc_sweep47(fsoc*c);
void gc_mark47(T47*o);
void gc_align_mark47(fsoc*c,gc47*p);
extern fsoc H47;
T47*new47(void);
void gc_sweep48(fsoc*c);
void gc_mark48(T48*o);
void gc_align_mark48(fsoc*c,gc48*p);
extern fsoc H48;
T48*new48(void);
void gc_sweep167(fsoc*c);
void gc_mark167(T167*o);
void gc_align_mark167(fsoc*c,gc167*p);
extern fsoc H167;
T167*new167(void);
void gc_sweep49(fsoc*c);
void gc_mark49(T49*o);
void gc_align_mark49(fsoc*c,gc49*p);
extern fsoc H49;
T49*new49(void);
void gc_sweep180(fsoc*c);
void gc_mark180(T180*o);
void gc_align_mark180(fsoc*c,gc180*p);
extern fsoc H180;
T180*new180(void);
void gc_sweep179(fsoc*c);
void gc_mark179(T179*o);
void gc_align_mark179(fsoc*c,gc179*p);
extern fsoc H179;
T179*new179(void);
void gc_sweep169(fsoc*c);
void gc_mark169(T169*o);
void gc_align_mark169(fsoc*c,gc169*p);
extern fsoc H169;
T169*new169(void);
void gc_sweep176(fsoc*c);
void gc_mark176(T176*o);
void gc_align_mark176(fsoc*c,gc176*p);
extern fsoc H176;
T176*new176(void);
void gc_sweep177(fsoc*c);
void gc_mark177(T177*o);
void gc_align_mark177(fsoc*c,gc177*p);
extern fsoc H177;
T177*new177(void);
void gc_sweep125(fsoc*c);
void gc_mark125(T125*o);
void gc_align_mark125(fsoc*c,gc125*p);
extern fsoc H125;
T125*new125(void);
void gc_sweep173(fsoc*c);
void gc_mark173(T173*o);
void gc_align_mark173(fsoc*c,gc173*p);
extern fsoc H173;
T173*new173(void);
void gc_sweep123(fsoc*c);
void gc_mark123(T123*o);
void gc_align_mark123(fsoc*c,gc123*p);
extern fsoc H123;
T123*new123(void);
void gc_sweep172(fsoc*c);
void gc_mark172(T172*o);
void gc_align_mark172(fsoc*c,gc172*p);
extern fsoc H172;
T172*new172(void);
void gc_sweep58(fsoc*c);
void gc_mark58(T58*o);
void gc_align_mark58(fsoc*c,gc58*p);
extern fsoc H58;
T58*new58(void);
void gc_sweep40(fsoc*c);
void gc_mark40(T40*o);
void gc_align_mark40(fsoc*c,gc40*p);
extern fsoc H40;
T40*new40(void);
void gc_sweep25(fsoc*c);
void gc_mark25(T25*o);
void gc_align_mark25(fsoc*c,gc25*p);
extern fsoc H25;
T25*new25(void);
void gc_mark9(T9 o);
T9 new9(unsigned int size);
void gc_sweep7(fsoc*c);
void gc_mark7(T7*o);
void gc_align_mark7(fsoc*c,gc7*p);
extern fsoc H7;
T7*new7(void);
extern T25*eiffel_root_object;
extern int se_argc;
extern char**se_argv;
#define SE_MAXID 184
extern T7*g[];
extern T7*t[];
extern char*p[];
extern void(*se_prinT[184])(FILE*,void*);
extern int se_strucT[];
void se_atexit(void);
void initialize_eiffel_runtime(int argc,char*argv[]);
int main(int argc,char*argv[]);

#ifdef __cplusplus
}
#endif
